import { canMiniShelvesBeCycled, cycleMiniShelves, getSegmentIndex, getSegmentOnAir, isMiniShelf } from './tab-cycle-helper'
import { Rundown } from '../../../core/models/rundown'
import { instance, mock, when } from '@typestrong/ts-mockito'
import { Logger } from '../../../core/abstractions/logger.service'
import { Segment } from '../../../core/models/segment'
import { CycleDirection } from '../../../core/models/cycle-direction'

describe('TabCycleHelper', () => {
  describe(canMiniShelvesBeCycled.name, () => {
    it('is false when rundown has no segments', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      when(mockedRundown.segments).thenReturn([])
      const mockLogger: Logger = mock<Logger>()
      const result: boolean = canMiniShelvesBeCycled(instance(mockedRundown), instance(mockLogger))
      expect(result).toBeFalse()
    })
    it('is false when rundown has no segment OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const mockLogger: Logger = mock<Logger>()
      const result: boolean = canMiniShelvesBeCycled(instance(mockedRundown), instance(mockLogger))
      expect(result).toBeFalse()
    })
    it('is false when rundown has a single segment even OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(true)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const mockLogger: Logger = mock<Logger>()
      const result: boolean = canMiniShelvesBeCycled(instance(mockedRundown), instance(mockLogger))
      expect(result).toBeFalse()
    })
    it('is false when rundown has more than a single segment none OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(false)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const mockLogger: Logger = mock<Logger>()
      const result: boolean = canMiniShelvesBeCycled(instance(mockedRundown), instance(mockLogger))
      expect(result).toBeFalse()
    })
    it('is true when rundown has more than a single segment and one is OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(true)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const mockLogger: Logger = mock<Logger>()
      const result: boolean = canMiniShelvesBeCycled(instance(mockedRundown), instance(mockLogger))
      expect(result).toBeTrue()
    })
  })
  describe(getSegmentOnAir.name, () => {
    it('is undefined when rundown has no segments', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      when(mockedRundown.segments).thenReturn([])
      const result: Segment | undefined = getSegmentOnAir(instance(mockedRundown))
      expect(result).toBeUndefined()
    })
    it('is undefined when rundown has no segment OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const result: Segment | undefined = getSegmentOnAir(instance(mockedRundown))
      expect(result).toBeUndefined()
    })
    it('is defined when rundown has a single segment even OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(true)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const result: Segment | undefined = getSegmentOnAir(instance(mockedRundown))
      expect(result).toBeDefined()
      expect(result).toEqual(instance(mockedSegment))
    })
    it('is defined when rundown has more than a single segment and one is OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(true)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const result: Segment | undefined = getSegmentOnAir(instance(mockedRundown))
      expect(result).toBeDefined()
      expect(result).toEqual(instance(mockedSegmentTwo))
    })
  })
  describe(isMiniShelf.name, () => {
    it('is false when segment has metadata with miniShelfVideoClipFile but is not hidden', () => {
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.metadata).thenReturn({ miniShelfVideoClipFile: 'someFile' })
      when(mockedSegment.isHidden).thenReturn(false)
      const result: boolean = isMiniShelf(instance(mockedSegment))
      expect(result).toBeFalse()
    })
    it('is true when segment has metadata with miniShelfVideoClipFile and is hidden', () => {
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.metadata).thenReturn({ miniShelfVideoClipFile: 'someFile' })
      when(mockedSegment.isHidden).thenReturn(true)
      const result: boolean = isMiniShelf(instance(mockedSegment))
      expect(result).toBeTrue()
    })
  })
  describe(getSegmentIndex.name, () => {
    it('is -1 when segment is undefined', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const result: number = getSegmentIndex(undefined, instance(mockedRundown))
      expect(result).toEqual(-1)
    })
    it('is -1 when segment is not found in rundown', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedRundown.segments).thenReturn([])
      const result: number = getSegmentIndex(instance(mockedSegment), instance(mockedRundown))
      expect(result).toEqual(-1)
    })
    it('is the index when segment is found in rundown', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo)])
      const result: number = getSegmentIndex(instance(mockedSegmentTwo), instance(mockedRundown))
      expect(result).toEqual(1)
    })
  })
  describe(cycleMiniShelves.name, () => {
    it('returns -1 and undefined when rundown has no segments', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      when(mockedRundown.segments).thenReturn([])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has no segment OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has a single segment even OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegment: Segment = mock<Segment>()
      when(mockedSegment.isOnAir).thenReturn(true)
      when(mockedRundown.segments).thenReturn([instance(mockedSegment)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has more than a single segment none OnAir', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(false)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has more than a single segment and one is OnAir but no miniShelves', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(true)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has more than a single segment and one is OnAir and one miniShelf and direction is PREVIOUS', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(true)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedSegmentThree.isHidden).thenReturn(true)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.PREVIOUS, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
    it('returns -1 and undefined when rundown has more than a single segment and one is OnAir and one miniShelf and direction is NEXT and actionId is not found', () => {
      const mockedRundown: Rundown = mock<Rundown>()
      const mockedSegmentOne: Segment = mock<Segment>()
      when(mockedSegmentOne.isOnAir).thenReturn(false)
      const mockedSegmentTwo: Segment = mock<Segment>()
      when(mockedSegmentTwo.isOnAir).thenReturn(true)
      const mockedSegmentThree: Segment = mock<Segment>()
      when(mockedSegmentThree.isOnAir).thenReturn(false)
      when(mockedSegmentThree.isHidden).thenReturn(true)
      when(mockedRundown.segments).thenReturn([instance(mockedSegmentOne), instance(mockedSegmentTwo), instance(mockedSegmentThree)])
      const result: [number, string | undefined] = cycleMiniShelves(CycleDirection.NEXT, instance(mockedRundown), -1, {})
      expect(result).toEqual([-1, undefined])
    })
  })
})
